<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChatHistoryState">
    <option name="serializedSessions">
      <map>
        <entry key="013bfb46-9f23-44ca-96be-b168e8895d3d" value="{&quot;id&quot;:&quot;013bfb46-9f23-44ca-96be-b168e8895d3d&quot;,&quot;name&quot;:&quot;[TextContent(type\u003dtext, text\u003d\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003cattached_files\u003e\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/duyvv/sorrow_knight/ui/GameView.kt, lines\u003dALL(1-752)\npackage com.duyvv.sorrow_knight.ui\n\nimport android.content.Context\nimport android.graphics.Bitmap\nimport android.graphics.BitmapFactory\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.graphics.Rect\nimport android.graphics.RectF\nimport android.util.AttributeSet\nimport android.util.Log\nimport android.view.View\nimport androidx.core.graphics.withScale\nimport androidx.media3.common.MediaItem\nimport androidx.media3.exoplayer.ExoPlayer\nimport com.duyvv.sorrow_knight.R\nimport com.duyvv.sorrow_knight.model.Enemy\nimport com.duyvv.sorrow_knight.model.MapItem\nimport androidx.core.net.toUri\nimport androidx.media3.common.Player\n\nclass GameView(context: Context, attrs: AttributeSet? \u003d null) : View(context, attrs) {\n\n    private val TAG \u003d this::class.java.simpleName\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d SPRITE \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    // Run sprite\n    private val runSprite \u003d BitmapFactory.decodeResource(resources, R.drawable.archer_run)\n    private val runTotalFrames \u003d 6\n    private val runFrameWidth \u003d runSprite.width / runTotalFrames\n    private val runFrameHeight \u003d runSprite.height\n\n    // Attack sprite\n    private val attackSprite \u003d BitmapFactory.decodeResource(resources, R.drawable.archer_attack)\n    private val attackTotalFrames \u003d 8\n    private val attackFrameWidth \u003d attackSprite.width / attackTotalFrames\n    private val attackFrameHeight \u003d attackSprite.height\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d ANIMATION \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private var currentFrame \u003d 0\n    private var frameTimer \u003d 0L\n    private val frameDuration \u003d 120L // ms mỗi frame\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d STATE \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private var isAttacking \u003d false\n    private var hasFiredArrowThisAttack \u003d false\n    private var isMoving \u003d false\n    private var lastWallHitTime \u003d 0L\n    private val wallHitCooldownMs \u003d 200L\n\n    // Vị trí nhân vật\n    private var characterX \u003d 0f\n    private var characterY \u003d 0f\n    private val speed \u003d 16f\n    private val scale \u003d 0.25f\n\n    // Hướng nhân vật (quay mặt)\n    private var facingLeft \u003d false\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d VẼ \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private val srcRect \u003d Rect()\n    private val dstRect \u003d RectF()\n    private val paint \u003d Paint(Paint.ANTI_ALIAS_FLAG).apply { isFilterBitmap \u003d true }\n\n    // Hitbox màu hồng để debug\n    private val hitboxPaint \u003d Paint().apply {\n        color \u003d Color.argb(100, 0, 200, 255)\n        style \u003d Paint.Style.FILL\n    }\n\n    // Hitbox quái để debug\n    private val enemyHitboxPaint \u003d Paint().apply {\n        color \u003d Color.argb(100, 0, 200, 255)\n        style \u003d Paint.Style.FILL\n    }\n\n    // Temp rects to avoid per-frame allocations\n    private val enemySrcRect \u003d Rect()\n    private val enemyDstRect \u003d RectF()\n    private val playerBoxRect \u003d RectF()\n    private val enemyHitboxRect \u003d RectF()\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d PROJECTILES \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private data class Arrow(\n        var x: Float,\n        var y: Float,\n        val speedPxPerFrame: Float,\n        val movingLeft: Boolean\n    )\n    private val arrows \u003d mutableListOf\u003cArrow\u003e()\n    private val arrowBitmap: Bitmap by lazy { BitmapFactory.decodeResource(resources, R.drawable.arrow) }\n    private val arrowScale \u003d 0.5f\n    private var arrowSpeedPxPerFrameDefault \u003d 18f\n\n    fun setArrowSpeed(speedPxPerFrame: Float) {\n        arrowSpeedPxPerFrameDefault \u003d speedPxPerFrame\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d AUDIO \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private var attackPlayer: ExoPlayer? \u003d null\n    private var hitSoundPlayer: ExoPlayer? \u003d null\n    private var isEnabledSound \u003d true\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d DIRECTION \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    enum class Direction { UP, DOWN, LEFT, RIGHT }\n    private var movingDirection: Direction? \u003d null\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d ITEMS \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private val items \u003d mutableListOf\u003cMapItem\u003e()\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d ENEMIES \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private val enemies \u003d mutableListOf\u003cEnemy\u003e()\n\n    private data class EnemyAnimConfig(\n        val idleSheet: Bitmap,\n        val moveSheet: Bitmap,\n        val attackSheet: Bitmap,\n        val idleColumns: Int,\n        val moveColumns: Int,\n        val attackColumns: Int,\n        val frameDurationMs: Long,\n        val scale: Float,\n        val paddingHorizontal: Int \u003d 0,\n        val paddingVertical: Int \u003d 0,\n        val hitboxInsetXRatio: Float \u003d 0.25f,\n        val hitboxInsetYRatio: Float \u003d 0.30f\n    )\n\n    private val torchConfig: EnemyAnimConfig by lazy {\n        EnemyAnimConfig(\n            idleSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.torch_idle),\n            moveSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.torch_move),\n            attackSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.torch_attack),\n            idleColumns \u003d 6,\n            moveColumns \u003d 6,\n            attackColumns \u003d 6,\n            frameDurationMs \u003d 120L,\n            scale \u003d 0.5f\n        )\n    }\n\n    private val warriorConfig: EnemyAnimConfig by lazy {\n        EnemyAnimConfig(\n            idleSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.warrior_run), // dùng run làm idle\n            moveSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.warrior_run),\n            attackSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.warrior_attack),\n            idleColumns \u003d 6,\n            moveColumns \u003d 6,\n            attackColumns \u003d 8,\n            frameDurationMs \u003d 110L,\n            scale \u003d 0.5f,\n            paddingHorizontal \u003d 60,\n            paddingVertical \u003d 80,\n            hitboxInsetXRatio \u003d 0.22f,\n            hitboxInsetYRatio \u003d 0.28f\n        )\n    }\n\n    private val tntConfig: EnemyAnimConfig by lazy {\n        EnemyAnimConfig(\n            idleSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.tnt_idle),\n            moveSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.tnt_run),\n            attackSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.tnt_attack),\n            idleColumns \u003d 6,\n            moveColumns \u003d 6,\n            attackColumns \u003d 6,\n            frameDurationMs \u003d 100L,\n            scale \u003d 0.55f\n        )\n    }\n\n    private fun getConfig(type: Enemy.Type): EnemyAnimConfig \u003d when (type) {\n        Enemy.Type.TORCH -\u003e torchConfig\n        Enemy.Type.WARRIOR -\u003e warriorConfig\n        Enemy.Type.TNT -\u003e tntConfig\n    }\n\n    private var lastSpawnTime \u003d 0L\n    private val spawnIntervalMs \u003d 100000L\n    private val maxEnemies \u003d 3\n    private val minEnemiesAtStart \u003d 3\n    private var previousAliveEnemies \u003d 0\n\n    // Player state (simple health and hit cooldown)\n    private var playerHealth \u003d 3\n    private var lastHitTime \u003d 0L\n    private val hitCooldownMs \u003d 800L\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d Lifecycle \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {\n        super.onSizeChanged(w, h, oldw, oldh)\n        setupCharacterPosition(h)\n        // Spawn đúng 3 quái: Torch, Warrior, TNT\n        enemies.clear()\n        spawnEnemy(Enemy.Type.TORCH)\n        spawnEnemy(Enemy.Type.WARRIOR)\n        spawnEnemy(Enemy.Type.TNT)\n        previousAliveEnemies \u003d enemies.count { !it.isDestroyed }\n        initAudio()\n    }\n\n    fun initAudio() {\n        attackPlayer \u003d ExoPlayer.Builder(context).build().apply {\n            val mediaItem \u003d MediaItem.fromUri(\&quot;android.resource://${context.packageName}/${R.raw.pew}\&quot;.toUri())\n            setMediaItem(mediaItem)\n            prepare()\n            playWhenReady \u003d false\n            repeatMode \u003d Player.REPEAT_MODE_OFF\n        }\n        hitSoundPlayer \u003d ExoPlayer.Builder(context).build().apply {\n            val mediaItem \u003d MediaItem.fromUri(\&quot;android.resource://${context.packageName}/${R.raw.hit}\&quot;.toUri())\n            setMediaItem(mediaItem)\n            prepare()\n            playWhenReady \u003d false\n            repeatMode \u003d Player.REPEAT_MODE_OFF\n        }\n    }\n\n    override fun onDetachedFromWindow() {\n        super.onDetachedFromWindow()\n        attackPlayer?.release()\n        attackPlayer \u003d null\n        hitSoundPlayer?.release()\n        hitSoundPlayer \u003d null\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n\n        updateCharacterState()\n        updateAnimationFrame()\n        updateEnemies()\n        updateArrows()\n\n//        drawItems(canvas)\n        drawEnemies(canvas)\n        drawArrows(canvas)\n        drawCharacter(canvas)\n\n        postInvalidateOnAnimation()\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d INIT \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private fun initItems() {\n        val chestBitmap \u003d BitmapFactory.decodeResource(resources, R.drawable.chest)\n        val chest \u003d MapItem(\n            id \u003d \&quot;chest_1\&quot;,\n            x \u003d width / 2f - chestBitmap.width / 2,\n            y \u003d height / 2f - chestBitmap.height / 2,\n            bitmap \u003d chestBitmap\n        )\n        items.add(chest)\n    }\n\n    private fun setupCharacterPosition(viewHeight: Int) {\n        characterX \u003d 0f\n        characterY \u003d (viewHeight - runFrameHeight * scale) / 2f\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d DRAW \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private fun drawItems(canvas: Canvas) {\n        for (item in items) {\n            if (!item.isDestroyed) {\n                canvas.drawBitmap(item.bitmap, item.x, item.y, paint)\n            }\n        }\n    }\n\n    private fun drawEnemies(canvas: Canvas) {\n        for (enemy in enemies) {\n            if (enemy.isDestroyed) continue\n            val cfg \u003d getConfig(enemy.type)\n            val (sheet, columns) \u003d when (enemy.state) {\n                Enemy.State.ATTACK -\u003e cfg.attackSheet to cfg.attackColumns\n                Enemy.State.MOVE -\u003e cfg.moveSheet to cfg.moveColumns\n                else -\u003e cfg.idleSheet to cfg.idleColumns\n            }\n            val frame \u003d enemy.currentFrame\n            val fw \u003d sheet.width / columns\n            val fh \u003d sheet.height\n            val srcLeft \u003d frame * fw + cfg.paddingHorizontal\n            val srcTop \u003d 0 + cfg.paddingVertical\n            val srcRight \u003d (frame + 1) * fw - cfg.paddingHorizontal\n            val srcBottom \u003d fh - cfg.paddingVertical\n            enemySrcRect.set(srcLeft, srcTop, srcRight, srcBottom)\n\n            enemyDstRect.set(\n                enemy.x,\n                enemy.y,\n                enemy.x + fw * cfg.scale,\n                enemy.y + fh * cfg.scale\n            )\n\n            // Vẽ hitbox quái để debug\n//            getEnemyHitboxInto(enemy, enemyHitboxRect)\n//            canvas.drawRect(enemyHitboxRect, enemyHitboxPaint)\n\n            // Lật ảnh theo hướng nhìn\n            val centerX \u003d enemyDstRect.centerX()\n            if (enemy.facingLeft) {\n                canvas.withScale(-1f, 1f, centerX, enemyDstRect.centerY()) {\n                    drawBitmap(sheet, enemySrcRect, enemyDstRect, paint)\n                }\n            } else {\n                canvas.drawBitmap(sheet, enemySrcRect, enemyDstRect, paint)\n            }\n        }\n    }\n\n    private fun drawArrows(canvas: Canvas) {\n        if (arrowBitmap.width \u003c\u003d 0 || arrowBitmap.height \u003c\u003d 0) return\n        for (arrow in arrows) {\n            val left \u003d arrow.x\n            val top \u003d arrow.y\n            val right \u003d arrow.x + arrowBitmap.width * arrowScale\n            val bottom \u003d arrow.y + arrowBitmap.height * arrowScale\n            dstRect.set(left, top, right, bottom)\n\n            val centerX \u003d dstRect.centerX()\n            if (arrow.movingLeft) {\n                canvas.withScale(-1f, 1f, centerX, dstRect.centerY()) {\n                    drawBitmap(arrowBitmap, null, dstRect, paint)\n                }\n            } else {\n                canvas.drawBitmap(arrowBitmap, null, dstRect, paint)\n            }\n        }\n    }\n\n    private fun drawCharacter(canvas: Canvas) {\n        val bitmap: Bitmap\n        val frameWidth: Int\n        val frameHeight: Int\n        val totalFrames: Int\n\n        when {\n            isAttacking -\u003e {\n                bitmap \u003d attackSprite\n                frameWidth \u003d attackFrameWidth\n                frameHeight \u003d attackFrameHeight\n                totalFrames \u003d attackTotalFrames\n            }\n\n            isMoving -\u003e {\n                bitmap \u003d runSprite\n                frameWidth \u003d runFrameWidth\n                frameHeight \u003d runFrameHeight\n                totalFrames \u003d runTotalFrames\n            }\n\n            else -\u003e {\n                bitmap \u003d runSprite\n                frameWidth \u003d runFrameWidth\n                frameHeight \u003d runFrameHeight\n                totalFrames \u003d runTotalFrames\n                currentFrame \u003d 0\n            }\n        }\n\n        // Cắt frame từ sprite sheet\n        val paddingVertical \u003d 80\n        val paddingHorizontal \u003d 60\n        srcRect.set(\n            currentFrame * frameWidth + paddingHorizontal, // paddingLeft: khoảng cách giữa các frame\n            paddingVertical, // paddingTop: khoảng cách giữa các frame (nếu có)\n            (currentFrame + 1) * frameWidth - paddingHorizontal,\n            frameHeight - paddingVertical // paddingBottom: khoảng cách dưới cùng\n        )\n\n        // Vị trí đích\n        dstRect.set(\n            characterX,\n            characterY,\n            characterX + frameWidth * scale,\n            characterY + frameHeight * scale\n        )\n\n        // Tính điểm giữa để lật ảnh\n        val centerX \u003d dstRect.centerX()\n\n        if (facingLeft) {\n            // Lật ảnh ngang sang trái\n            canvas.withScale(-1f, 1f, centerX, dstRect.centerY()) {\n                drawBitmap(bitmap, srcRect, dstRect, paint)\n            }\n        } else {\n            // Bình thường (mặt phải)\n            canvas.drawBitmap(bitmap, srcRect, dstRect, paint)\n        }\n//        drawHitbox(canvas)\n    }\n\n    private fun drawHitbox(canvas: Canvas) {\n        canvas.drawRect(dstRect, hitboxPaint)\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d UPDATE \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private fun updateCharacterState() {\n        isMoving \u003d movingDirection !\u003d null\n\n        movingDirection?.let { dir -\u003e\n            val oldX \u003d characterX\n            val oldY \u003d characterY\n            \n            when (dir) {\n                Direction.UP -\u003e characterY -\u003d speed\n                Direction.DOWN -\u003e characterY +\u003d speed\n                Direction.LEFT -\u003e {\n                    characterX -\u003d speed\n                    facingLeft \u003d true // quay mặt trái\n                }\n\n                Direction.RIGHT -\u003e {\n                    characterX +\u003d speed\n                    facingLeft \u003d false // quay mặt phải\n                }\n            }\n\n            // Giới hạn trong màn hình và phát âm thanh khi chạm tường\n            val maxX \u003d width - runFrameWidth * scale\n            val maxY \u003d height - runFrameHeight * scale\n            val newX \u003d characterX.coerceIn(0f, maxX)\n            val newY \u003d characterY.coerceIn(0f, maxY)\n            \n            // Kiểm tra xem có chạm tường không\n            val hitWall \u003d (newX !\u003d characterX) || (newY !\u003d characterY)\n            if (hitWall) {\n                val now \u003d System.currentTimeMillis()\n                if (now - lastWallHitTime \u003e wallHitCooldownMs) {\n                    playWallHitSound()\n                    lastWallHitTime \u003d now\n                }\n            }\n            \n            characterX \u003d newX\n            characterY \u003d newY\n        }\n    }\n\n    private fun updateAnimationFrame() {\n        if (isAttacking || isMoving) {\n            val now \u003d System.currentTimeMillis()\n            if (now - frameTimer \u003e frameDuration) {\n                val total \u003d if (isAttacking) attackTotalFrames else runTotalFrames\n                currentFrame \u003d (currentFrame + 1) % total\n                frameTimer \u003d now\n                // Bắn mũi tên ở frame 6 (0-based)\n                val attackHitFrameIndex \u003d 6\n                if (isAttacking \u0026\u0026 !hasFiredArrowThisAttack) {\n                    // Spawn arrow aligned to character vertical center\n                    val arrowStartX \u003d if (facingLeft) characterX else characterX + runFrameWidth * scale - (arrowBitmap.width * arrowScale) * 0.25f\n                    val playerCenterY \u003d characterY + (runFrameHeight * scale) / 2f\n                    val arrowHeight \u003d arrowBitmap.height * arrowScale\n                    val arrowStartY \u003d playerCenterY - arrowHeight / 2f\n                    arrows.add(\n                        Arrow(\n                            x \u003d arrowStartX,\n                            y \u003d arrowStartY,\n                            speedPxPerFrame \u003d arrowSpeedPxPerFrameDefault,\n                            movingLeft \u003d facingLeft\n                        )\n                    )\n                    hasFiredArrowThisAttack \u003d true\n                    playAttackSound()\n                }\n            }\n        } else {\n            currentFrame \u003d 0\n        }\n    }\n\n    private fun updateEnemies() {\n        val now \u003d System.currentTimeMillis()\n\n        // Quản lý số lượng quái: đảm bảo tối thiểu và thay thế ngay khi bị tiêu diệt, tối đa 3\n        val aliveBefore \u003d enemies.count { !it.isDestroyed }\n        if (aliveBefore \u003c minEnemiesAtStart) {\n            // Bổ sung các loại thiếu để đủ 3 loại khác nhau\n            val existingTypes \u003d enemies.filter { !it.isDestroyed }.map { it.type }.toMutableSet()\n            if (!existingTypes.contains(Enemy.Type.TORCH)) spawnEnemy(Enemy.Type.TORCH)\n            if (!existingTypes.contains(Enemy.Type.WARRIOR)) spawnEnemy(Enemy.Type.WARRIOR)\n            if (!existingTypes.contains(Enemy.Type.TNT)) spawnEnemy(Enemy.Type.TNT)\n        } else if (aliveBefore \u003c previousAliveEnemies \u0026\u0026 aliveBefore \u003c maxEnemies) {\n            // Trường hợp có kẻ địch bị diệt, sẽ respawn cùng loại đó trong checkEnemyHit\n        }\n\n        // Update positions and check collisions\n        playerBoxRect.set(\n            characterX,\n            characterY,\n            characterX + runFrameWidth * scale,\n            characterY + runFrameHeight * scale\n        )\n\n        for (enemy in enemies) {\n            if (enemy.isDestroyed) continue\n            // Di chuyển ngang một hướng cố định, wrap khi qua rìa\n            if (enemy.state !\u003d Enemy.State.ATTACK) {\n                val speed \u003d enemy.speedPxPerFrame\n                if (enemy.movingLeft) {\n                    enemy.x -\u003d speed\n                    enemy.facingLeft \u003d true\n                } else {\n                    enemy.x +\u003d speed\n                    enemy.facingLeft \u003d false\n                }\n\n                val cfgMove \u003d getConfig(enemy.type)\n                val fwMove \u003d (cfgMove.moveSheet.width / cfgMove.moveColumns)\n                val spriteWidth \u003d fwMove * cfgMove.scale\n                val quickOffset \u003d spriteWidth * 0.25f\n                // Nếu ra khỏi rìa trái, xuất hiện bên phải (vào nhanh hơn một chút)\n                if (enemy.x + spriteWidth \u003c 0f) {\n                    enemy.x \u003d width.toFloat() - quickOffset\n                }\n                // Nếu ra khỏi rìa phải, xuất hiện bên trái (vào nhanh hơn một chút)\n                if (enemy.x \u003e width.toFloat()) {\n                    enemy.x \u003d -spriteWidth + quickOffset\n                }\n            }\n\n            // Khoảng cách theo cả X và Y\n            val cfgForRange \u003d getConfig(enemy.type)\n            val fwRange \u003d (cfgForRange.moveSheet.width / cfgForRange.moveColumns)\n            val fhRange \u003d cfgForRange.moveSheet.height\n            val enemyCenterX \u003d enemy.x + (fwRange * cfgForRange.scale) / 2f\n            val enemyCenterY \u003d enemy.y + (fhRange * cfgForRange.scale) / 2f\n            val playerCenterX \u003d characterX + (runFrameWidth * scale) / 2f\n            val playerCenterY \u003d characterY + (runFrameHeight * scale) / 2f\n            val distX \u003d kotlin.math.abs(playerCenterX - enemyCenterX)\n            val distY \u003d kotlin.math.abs(playerCenterY - enemyCenterY)\n            val attackRangeX \u003d fwRange * cfgForRange.scale * 0.6f\n            val attackRangeY \u003d fhRange * cfgForRange.scale * 0.6f\n\n            // Xác định state\n            val shouldAttack \u003d distX \u003c attackRangeX \u0026\u0026 distY \u003c attackRangeY\n            if (shouldAttack) {\n                enemy.state \u003d Enemy.State.ATTACK\n                enemy.facingLeft \u003d playerCenterX \u003c enemyCenterX\n            } else {\n                enemy.state \u003d Enemy.State.MOVE\n            }\n\n            // Cập nhật frame animation\n            val cfgForAnim \u003d getConfig(enemy.type)\n            val duration \u003d cfgForAnim.frameDurationMs\n            if (now - enemy.frameTimerMs \u003e duration) {\n                val looping \u003d enemy.state \u003d\u003d Enemy.State.ATTACK || enemy.state \u003d\u003d Enemy.State.MOVE\n                if (looping) {\n                    val columns \u003d when (enemy.state) {\n                        Enemy.State.ATTACK -\u003e cfgForAnim.attackColumns\n                        Enemy.State.MOVE -\u003e cfgForAnim.moveColumns\n                        else -\u003e cfgForAnim.idleColumns\n                    }\n                    enemy.currentFrame \u003d (enemy.currentFrame + 1) % columns\n                    if (enemy.currentFrame \u003d\u003d 0) {\n                        if (enemy.state \u003d\u003d Enemy.State.ATTACK) enemy.attackReady \u003d true\n                        enemy.dealtDamageThisAttack \u003d false\n                    }\n                } else {\n                    enemy.currentFrame \u003d 0\n                }\n                enemy.frameTimerMs \u003d now\n            }\n\n            // Enemy attacks on contact\n            getEnemyHitboxInto(enemy, enemyHitboxRect)\n            if (RectF.intersects(playerBoxRect, enemyHitboxRect)) {\n                val canDamage \u003d if (enemy.state \u003d\u003d Enemy.State.ATTACK) (enemy.attackReady \u0026\u0026 !enemy.dealtDamageThisAttack) else now - lastHitTime \u003e hitCooldownMs\n                if (canDamage) {\n                    playerHealth \u003d (playerHealth - 1).coerceAtLeast(0)\n                    lastHitTime \u003d now\n                    Log.d(TAG, \&quot;Player bị tấn công! Máu còn: $playerHealth\&quot;)\n                    if (enemy.state \u003d\u003d Enemy.State.ATTACK) {\n                        enemy.dealtDamageThisAttack \u003d true\n                        enemy.attackReady \u003d false\n                    }\n                }\n            }\n        }\n\n        // Remove destroyed enemies, giữ lại để wrap-around khi ra khỏi màn hình\n        enemies.removeAll { it.isDestroyed }\n\n        // Nếu ít hơn tối đa, có thể spawn thêm để đạt tối đa 3 khi muốn\n        val aliveAfter \u003d enemies.count { !it.isDestroyed }\n        if (aliveAfter \u003c maxEnemies \u0026\u0026 aliveAfter \u003c minEnemiesAtStart) {\n            // Bổ sung những loại còn thiếu\n            val existingTypes \u003d enemies.filter { !it.isDestroyed }.map { it.type }.toMutableSet()\n            if (!existingTypes.contains(Enemy.Type.TORCH)) spawnEnemy(Enemy.Type.TORCH)\n            if (!existingTypes.contains(Enemy.Type.WARRIOR)) spawnEnemy(Enemy.Type.WARRIOR)\n            if (!existingTypes.contains(Enemy.Type.TNT)) spawnEnemy(Enemy.Type.TNT)\n        }\n        previousAliveEnemies \u003d enemies.count { !it.isDestroyed }\n    }\n\n    private fun updateArrows() {\n        if (arrowBitmap.width \u003c\u003d 0 || arrowBitmap.height \u003c\u003d 0) return\n        val iterator \u003d arrows.iterator()\n        while (iterator.hasNext()) {\n            val arrow \u003d iterator.next()\n            val dx \u003d if (arrow.movingLeft) -arrow.speedPxPerFrame else arrow.speedPxPerFrame\n            arrow.x +\u003d dx\n\n            // Remove when off-screen\n            if (arrow.x + arrowBitmap.width * arrowScale \u003c 0f || arrow.x \u003e width) {\n                iterator.remove()\n                continue\n            }\n\n            // Check collision with enemies\n            val arrowRect \u003d RectF(\n                arrow.x,\n                arrow.y,\n                arrow.x + arrowBitmap.width * arrowScale,\n                arrow.y + arrowBitmap.height * arrowScale\n            )\n            for (enemy in enemies) {\n                if (enemy.isDestroyed) continue\n                getEnemyHitboxInto(enemy, enemyHitboxRect)\n                if (RectF.intersects(arrowRect, enemyHitboxRect)) {\n                    enemy.health \u003d (enemy.health - 1).coerceAtLeast(0)\n                    if (enemy.health \u003d\u003d 0) enemy.isDestroyed \u003d true\n                    iterator.remove()\n                    break\n                }\n            }\n        }\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d CONTROL \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    fun startMoving(direction: Direction) {\n        movingDirection \u003d direction\n    }\n\n    fun stopMoving() {\n        movingDirection \u003d null\n    }\n\n    fun attack() {\n        Log.d(TAG, \&quot;attack: 1111\&quot;)\n        isAttacking \u003d true\n        currentFrame \u003d 0\n        hasFiredArrowThisAttack \u003d false\n        val characterBox \u003d RectF(\n            characterX,\n            characterY,\n            characterX + runFrameWidth * scale,\n            characterY + runFrameHeight * scale\n        )\n//        checkItemCollision(characterBox)\n        // Không gây sát thương ngay; damage sẽ áp dụng khi animation kết thúc (playerPendingAttack)\n\n        postDelayed({ isAttacking \u003d false }, 500)\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d COLLISION \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private fun checkItemCollision(characterBox: RectF) {\n        for (item in items) {\n            if (!item.isDestroyed \u0026\u0026 RectF.intersects(characterBox, item.getBoundingBox())) {\n                item.isDestroyed \u003d true\n                Log.d(TAG, \&quot;Item ${item.id} bị phá hủy!\&quot;)\n            }\n        }\n    }\n\n    private fun checkEnemyHit(characterBox: RectF) {\n        val killed \u003d ArrayList\u003cEnemy\u003e()\n        for (enemy in enemies) {\n            getEnemyHitboxInto(enemy, enemyHitboxRect)\n            if (RectF.intersects(characterBox, enemyHitboxRect)) {\n                enemy.health \u003d (enemy.health - 1).coerceAtLeast(0)\n                if (enemy.health \u003d\u003d 0) {\n                    killed.add(enemy)\n                }\n            }\n        }\n        if (killed.isNotEmpty()) {\n            enemies.removeAll(killed)\n            // Spawn replacements immediately up to maxEnemies\n            val canSpawn \u003d (maxEnemies - enemies.size).coerceAtLeast(0)\n            val toSpawn \u003d minOf(canSpawn, killed.size)\n            repeat(toSpawn) { index -\u003e\n                val typeToRespawn \u003d killed.getOrNull(index)?.type ?: Enemy.Type.TORCH\n                spawnEnemy(typeToRespawn)\n            }\n        }\n    }\n\n    private fun getEnemyHitboxInto(enemy: Enemy, outRect: RectF) {\n        val cfg \u003d getConfig(enemy.type)\n        val fw \u003d (cfg.moveSheet.width / cfg.moveColumns)\n        val fh \u003d cfg.moveSheet.height\n        val widthScaled \u003d fw * cfg.scale\n        val heightScaled \u003d fh * cfg.scale\n        val insetX \u003d widthScaled * cfg.hitboxInsetXRatio\n        val insetY \u003d heightScaled * cfg.hitboxInsetYRatio\n        outRect.set(\n            enemy.x + insetX,\n            enemy.y + insetY,\n            enemy.x + widthScaled - insetX,\n            enemy.y + heightScaled - insetY\n        )\n    }\n\n    private fun spawnEnemy(type: Enemy.Type) {\n        val cfg \u003d getConfig(type)\n        val frameWidth \u003d cfg.moveSheet.width / cfg.moveColumns\n        val frameHeight \u003d cfg.moveSheet.height\n        val maxX \u003d (width - frameWidth * cfg.scale).coerceAtLeast(0f)\n        val maxY \u003d (height - frameHeight * cfg.scale).coerceAtLeast(0f)\n        val spawnX \u003d (0..maxX.toInt()).random().toFloat()\n        val spawnY \u003d (0..maxY.toInt()).random().toFloat()\n        val enemy \u003d Enemy(\n            id \u003d \&quot;enemy_${System.currentTimeMillis()}\&quot;,\n            x \u003d spawnX,\n            y \u003d spawnY,\n            bitmap \u003d cfg.idleSheet,\n            type \u003d type,\n            speedPxPerFrame \u003d 2.5f,\n            health \u003d 4\n        )\n        enemy.movingLeft \u003d listOf(true, false).random()\n        enemies.add(enemy)\n    }\n\n    private fun playAttackSound() {\n        if (!isEnabledSound) return\n        try {\n            attackPlayer?.seekTo(0)\n            attackPlayer?.play()\n        } catch (e: Exception) {\n            Log.e(TAG, \&quot;Error playing attack sound\&quot;, e)\n        }\n    }\n\n    private fun playWallHitSound() {\n        if (!isEnabledSound) return\n        try {\n            hitSoundPlayer?.seekTo(0)\n            hitSoundPlayer?.play()\n        } catch (e: Exception) {\n            Log.e(TAG, \&quot;Error playing wall hit sound\&quot;, e)\n        }\n    }\n\n    fun toggleSound(isEnabled: Boolean) {\n        isEnabledSound \u003d isEnabled\n    }\n}\n\n```\n\u003c/file_contents\u003e\n\n\u003c/attached_files\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\n@GameView.kt vì mỗi frame của các enemy đều là 192x192 nên tôi muốn các enemy đều xử lý anim y hệt như con torch\n\u003c/user_query\u003e)]&quot;,&quot;timestamp&quot;:1758598997259,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003cattached_files\u003e\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/duyvv/sorrow_knight/ui/GameView.kt, lines\u003dALL(1-752)\npackage com.duyvv.sorrow_knight.ui\n\nimport android.content.Context\nimport android.graphics.Bitmap\nimport android.graphics.BitmapFactory\nimport android.graphics.Canvas\nimport android.graphics.Color\nimport android.graphics.Paint\nimport android.graphics.Rect\nimport android.graphics.RectF\nimport android.util.AttributeSet\nimport android.util.Log\nimport android.view.View\nimport androidx.core.graphics.withScale\nimport androidx.media3.common.MediaItem\nimport androidx.media3.exoplayer.ExoPlayer\nimport com.duyvv.sorrow_knight.R\nimport com.duyvv.sorrow_knight.model.Enemy\nimport com.duyvv.sorrow_knight.model.MapItem\nimport androidx.core.net.toUri\nimport androidx.media3.common.Player\n\nclass GameView(context: Context, attrs: AttributeSet? \u003d null) : View(context, attrs) {\n\n    private val TAG \u003d this::class.java.simpleName\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d SPRITE \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    // Run sprite\n    private val runSprite \u003d BitmapFactory.decodeResource(resources, R.drawable.archer_run)\n    private val runTotalFrames \u003d 6\n    private val runFrameWidth \u003d runSprite.width / runTotalFrames\n    private val runFrameHeight \u003d runSprite.height\n\n    // Attack sprite\n    private val attackSprite \u003d BitmapFactory.decodeResource(resources, R.drawable.archer_attack)\n    private val attackTotalFrames \u003d 8\n    private val attackFrameWidth \u003d attackSprite.width / attackTotalFrames\n    private val attackFrameHeight \u003d attackSprite.height\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d ANIMATION \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private var currentFrame \u003d 0\n    private var frameTimer \u003d 0L\n    private val frameDuration \u003d 120L // ms mỗi frame\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d STATE \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private var isAttacking \u003d false\n    private var hasFiredArrowThisAttack \u003d false\n    private var isMoving \u003d false\n    private var lastWallHitTime \u003d 0L\n    private val wallHitCooldownMs \u003d 200L\n\n    // Vị trí nhân vật\n    private var characterX \u003d 0f\n    private var characterY \u003d 0f\n    private val speed \u003d 16f\n    private val scale \u003d 0.25f\n\n    // Hướng nhân vật (quay mặt)\n    private var facingLeft \u003d false\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d VẼ \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private val srcRect \u003d Rect()\n    private val dstRect \u003d RectF()\n    private val paint \u003d Paint(Paint.ANTI_ALIAS_FLAG).apply { isFilterBitmap \u003d true }\n\n    // Hitbox màu hồng để debug\n    private val hitboxPaint \u003d Paint().apply {\n        color \u003d Color.argb(100, 0, 200, 255)\n        style \u003d Paint.Style.FILL\n    }\n\n    // Hitbox quái để debug\n    private val enemyHitboxPaint \u003d Paint().apply {\n        color \u003d Color.argb(100, 0, 200, 255)\n        style \u003d Paint.Style.FILL\n    }\n\n    // Temp rects to avoid per-frame allocations\n    private val enemySrcRect \u003d Rect()\n    private val enemyDstRect \u003d RectF()\n    private val playerBoxRect \u003d RectF()\n    private val enemyHitboxRect \u003d RectF()\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d PROJECTILES \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private data class Arrow(\n        var x: Float,\n        var y: Float,\n        val speedPxPerFrame: Float,\n        val movingLeft: Boolean\n    )\n    private val arrows \u003d mutableListOf\u003cArrow\u003e()\n    private val arrowBitmap: Bitmap by lazy { BitmapFactory.decodeResource(resources, R.drawable.arrow) }\n    private val arrowScale \u003d 0.5f\n    private var arrowSpeedPxPerFrameDefault \u003d 18f\n\n    fun setArrowSpeed(speedPxPerFrame: Float) {\n        arrowSpeedPxPerFrameDefault \u003d speedPxPerFrame\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d AUDIO \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private var attackPlayer: ExoPlayer? \u003d null\n    private var hitSoundPlayer: ExoPlayer? \u003d null\n    private var isEnabledSound \u003d true\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d DIRECTION \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    enum class Direction { UP, DOWN, LEFT, RIGHT }\n    private var movingDirection: Direction? \u003d null\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d ITEMS \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private val items \u003d mutableListOf\u003cMapItem\u003e()\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d ENEMIES \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private val enemies \u003d mutableListOf\u003cEnemy\u003e()\n\n    private data class EnemyAnimConfig(\n        val idleSheet: Bitmap,\n        val moveSheet: Bitmap,\n        val attackSheet: Bitmap,\n        val idleColumns: Int,\n        val moveColumns: Int,\n        val attackColumns: Int,\n        val frameDurationMs: Long,\n        val scale: Float,\n        val paddingHorizontal: Int \u003d 0,\n        val paddingVertical: Int \u003d 0,\n        val hitboxInsetXRatio: Float \u003d 0.25f,\n        val hitboxInsetYRatio: Float \u003d 0.30f\n    )\n\n    private val torchConfig: EnemyAnimConfig by lazy {\n        EnemyAnimConfig(\n            idleSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.torch_idle),\n            moveSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.torch_move),\n            attackSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.torch_attack),\n            idleColumns \u003d 6,\n            moveColumns \u003d 6,\n            attackColumns \u003d 6,\n            frameDurationMs \u003d 120L,\n            scale \u003d 0.5f\n        )\n    }\n\n    private val warriorConfig: EnemyAnimConfig by lazy {\n        EnemyAnimConfig(\n            idleSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.warrior_run), // dùng run làm idle\n            moveSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.warrior_run),\n            attackSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.warrior_attack),\n            idleColumns \u003d 6,\n            moveColumns \u003d 6,\n            attackColumns \u003d 8,\n            frameDurationMs \u003d 110L,\n            scale \u003d 0.5f,\n            paddingHorizontal \u003d 60,\n            paddingVertical \u003d 80,\n            hitboxInsetXRatio \u003d 0.22f,\n            hitboxInsetYRatio \u003d 0.28f\n        )\n    }\n\n    private val tntConfig: EnemyAnimConfig by lazy {\n        EnemyAnimConfig(\n            idleSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.tnt_idle),\n            moveSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.tnt_run),\n            attackSheet \u003d BitmapFactory.decodeResource(resources, R.drawable.tnt_attack),\n            idleColumns \u003d 6,\n            moveColumns \u003d 6,\n            attackColumns \u003d 6,\n            frameDurationMs \u003d 100L,\n            scale \u003d 0.55f\n        )\n    }\n\n    private fun getConfig(type: Enemy.Type): EnemyAnimConfig \u003d when (type) {\n        Enemy.Type.TORCH -\u003e torchConfig\n        Enemy.Type.WARRIOR -\u003e warriorConfig\n        Enemy.Type.TNT -\u003e tntConfig\n    }\n\n    private var lastSpawnTime \u003d 0L\n    private val spawnIntervalMs \u003d 100000L\n    private val maxEnemies \u003d 3\n    private val minEnemiesAtStart \u003d 3\n    private var previousAliveEnemies \u003d 0\n\n    // Player state (simple health and hit cooldown)\n    private var playerHealth \u003d 3\n    private var lastHitTime \u003d 0L\n    private val hitCooldownMs \u003d 800L\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d Lifecycle \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {\n        super.onSizeChanged(w, h, oldw, oldh)\n        setupCharacterPosition(h)\n        // Spawn đúng 3 quái: Torch, Warrior, TNT\n        enemies.clear()\n        spawnEnemy(Enemy.Type.TORCH)\n        spawnEnemy(Enemy.Type.WARRIOR)\n        spawnEnemy(Enemy.Type.TNT)\n        previousAliveEnemies \u003d enemies.count { !it.isDestroyed }\n        initAudio()\n    }\n\n    fun initAudio() {\n        attackPlayer \u003d ExoPlayer.Builder(context).build().apply {\n            val mediaItem \u003d MediaItem.fromUri(\&quot;android.resource://${context.packageName}/${R.raw.pew}\&quot;.toUri())\n            setMediaItem(mediaItem)\n            prepare()\n            playWhenReady \u003d false\n            repeatMode \u003d Player.REPEAT_MODE_OFF\n        }\n        hitSoundPlayer \u003d ExoPlayer.Builder(context).build().apply {\n            val mediaItem \u003d MediaItem.fromUri(\&quot;android.resource://${context.packageName}/${R.raw.hit}\&quot;.toUri())\n            setMediaItem(mediaItem)\n            prepare()\n            playWhenReady \u003d false\n            repeatMode \u003d Player.REPEAT_MODE_OFF\n        }\n    }\n\n    override fun onDetachedFromWindow() {\n        super.onDetachedFromWindow()\n        attackPlayer?.release()\n        attackPlayer \u003d null\n        hitSoundPlayer?.release()\n        hitSoundPlayer \u003d null\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n\n        updateCharacterState()\n        updateAnimationFrame()\n        updateEnemies()\n        updateArrows()\n\n//        drawItems(canvas)\n        drawEnemies(canvas)\n        drawArrows(canvas)\n        drawCharacter(canvas)\n\n        postInvalidateOnAnimation()\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d INIT \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private fun initItems() {\n        val chestBitmap \u003d BitmapFactory.decodeResource(resources, R.drawable.chest)\n        val chest \u003d MapItem(\n            id \u003d \&quot;chest_1\&quot;,\n            x \u003d width / 2f - chestBitmap.width / 2,\n            y \u003d height / 2f - chestBitmap.height / 2,\n            bitmap \u003d chestBitmap\n        )\n        items.add(chest)\n    }\n\n    private fun setupCharacterPosition(viewHeight: Int) {\n        characterX \u003d 0f\n        characterY \u003d (viewHeight - runFrameHeight * scale) / 2f\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d DRAW \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private fun drawItems(canvas: Canvas) {\n        for (item in items) {\n            if (!item.isDestroyed) {\n                canvas.drawBitmap(item.bitmap, item.x, item.y, paint)\n            }\n        }\n    }\n\n    private fun drawEnemies(canvas: Canvas) {\n        for (enemy in enemies) {\n            if (enemy.isDestroyed) continue\n            val cfg \u003d getConfig(enemy.type)\n            val (sheet, columns) \u003d when (enemy.state) {\n                Enemy.State.ATTACK -\u003e cfg.attackSheet to cfg.attackColumns\n                Enemy.State.MOVE -\u003e cfg.moveSheet to cfg.moveColumns\n                else -\u003e cfg.idleSheet to cfg.idleColumns\n            }\n            val frame \u003d enemy.currentFrame\n            val fw \u003d sheet.width / columns\n            val fh \u003d sheet.height\n            val srcLeft \u003d frame * fw + cfg.paddingHorizontal\n            val srcTop \u003d 0 + cfg.paddingVertical\n            val srcRight \u003d (frame + 1) * fw - cfg.paddingHorizontal\n            val srcBottom \u003d fh - cfg.paddingVertical\n            enemySrcRect.set(srcLeft, srcTop, srcRight, srcBottom)\n\n            enemyDstRect.set(\n                enemy.x,\n                enemy.y,\n                enemy.x + fw * cfg.scale,\n                enemy.y + fh * cfg.scale\n            )\n\n            // Vẽ hitbox quái để debug\n//            getEnemyHitboxInto(enemy, enemyHitboxRect)\n//            canvas.drawRect(enemyHitboxRect, enemyHitboxPaint)\n\n            // Lật ảnh theo hướng nhìn\n            val centerX \u003d enemyDstRect.centerX()\n            if (enemy.facingLeft) {\n                canvas.withScale(-1f, 1f, centerX, enemyDstRect.centerY()) {\n                    drawBitmap(sheet, enemySrcRect, enemyDstRect, paint)\n                }\n            } else {\n                canvas.drawBitmap(sheet, enemySrcRect, enemyDstRect, paint)\n            }\n        }\n    }\n\n    private fun drawArrows(canvas: Canvas) {\n        if (arrowBitmap.width \u003c\u003d 0 || arrowBitmap.height \u003c\u003d 0) return\n        for (arrow in arrows) {\n            val left \u003d arrow.x\n            val top \u003d arrow.y\n            val right \u003d arrow.x + arrowBitmap.width * arrowScale\n            val bottom \u003d arrow.y + arrowBitmap.height * arrowScale\n            dstRect.set(left, top, right, bottom)\n\n            val centerX \u003d dstRect.centerX()\n            if (arrow.movingLeft) {\n                canvas.withScale(-1f, 1f, centerX, dstRect.centerY()) {\n                    drawBitmap(arrowBitmap, null, dstRect, paint)\n                }\n            } else {\n                canvas.drawBitmap(arrowBitmap, null, dstRect, paint)\n            }\n        }\n    }\n\n    private fun drawCharacter(canvas: Canvas) {\n        val bitmap: Bitmap\n        val frameWidth: Int\n        val frameHeight: Int\n        val totalFrames: Int\n\n        when {\n            isAttacking -\u003e {\n                bitmap \u003d attackSprite\n                frameWidth \u003d attackFrameWidth\n                frameHeight \u003d attackFrameHeight\n                totalFrames \u003d attackTotalFrames\n            }\n\n            isMoving -\u003e {\n                bitmap \u003d runSprite\n                frameWidth \u003d runFrameWidth\n                frameHeight \u003d runFrameHeight\n                totalFrames \u003d runTotalFrames\n            }\n\n            else -\u003e {\n                bitmap \u003d runSprite\n                frameWidth \u003d runFrameWidth\n                frameHeight \u003d runFrameHeight\n                totalFrames \u003d runTotalFrames\n                currentFrame \u003d 0\n            }\n        }\n\n        // Cắt frame từ sprite sheet\n        val paddingVertical \u003d 80\n        val paddingHorizontal \u003d 60\n        srcRect.set(\n            currentFrame * frameWidth + paddingHorizontal, // paddingLeft: khoảng cách giữa các frame\n            paddingVertical, // paddingTop: khoảng cách giữa các frame (nếu có)\n            (currentFrame + 1) * frameWidth - paddingHorizontal,\n            frameHeight - paddingVertical // paddingBottom: khoảng cách dưới cùng\n        )\n\n        // Vị trí đích\n        dstRect.set(\n            characterX,\n            characterY,\n            characterX + frameWidth * scale,\n            characterY + frameHeight * scale\n        )\n\n        // Tính điểm giữa để lật ảnh\n        val centerX \u003d dstRect.centerX()\n\n        if (facingLeft) {\n            // Lật ảnh ngang sang trái\n            canvas.withScale(-1f, 1f, centerX, dstRect.centerY()) {\n                drawBitmap(bitmap, srcRect, dstRect, paint)\n            }\n        } else {\n            // Bình thường (mặt phải)\n            canvas.drawBitmap(bitmap, srcRect, dstRect, paint)\n        }\n//        drawHitbox(canvas)\n    }\n\n    private fun drawHitbox(canvas: Canvas) {\n        canvas.drawRect(dstRect, hitboxPaint)\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d UPDATE \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private fun updateCharacterState() {\n        isMoving \u003d movingDirection !\u003d null\n\n        movingDirection?.let { dir -\u003e\n            val oldX \u003d characterX\n            val oldY \u003d characterY\n            \n            when (dir) {\n                Direction.UP -\u003e characterY -\u003d speed\n                Direction.DOWN -\u003e characterY +\u003d speed\n                Direction.LEFT -\u003e {\n                    characterX -\u003d speed\n                    facingLeft \u003d true // quay mặt trái\n                }\n\n                Direction.RIGHT -\u003e {\n                    characterX +\u003d speed\n                    facingLeft \u003d false // quay mặt phải\n                }\n            }\n\n            // Giới hạn trong màn hình và phát âm thanh khi chạm tường\n            val maxX \u003d width - runFrameWidth * scale\n            val maxY \u003d height - runFrameHeight * scale\n            val newX \u003d characterX.coerceIn(0f, maxX)\n            val newY \u003d characterY.coerceIn(0f, maxY)\n            \n            // Kiểm tra xem có chạm tường không\n            val hitWall \u003d (newX !\u003d characterX) || (newY !\u003d characterY)\n            if (hitWall) {\n                val now \u003d System.currentTimeMillis()\n                if (now - lastWallHitTime \u003e wallHitCooldownMs) {\n                    playWallHitSound()\n                    lastWallHitTime \u003d now\n                }\n            }\n            \n            characterX \u003d newX\n            characterY \u003d newY\n        }\n    }\n\n    private fun updateAnimationFrame() {\n        if (isAttacking || isMoving) {\n            val now \u003d System.currentTimeMillis()\n            if (now - frameTimer \u003e frameDuration) {\n                val total \u003d if (isAttacking) attackTotalFrames else runTotalFrames\n                currentFrame \u003d (currentFrame + 1) % total\n                frameTimer \u003d now\n                // Bắn mũi tên ở frame 6 (0-based)\n                val attackHitFrameIndex \u003d 6\n                if (isAttacking \u0026\u0026 !hasFiredArrowThisAttack) {\n                    // Spawn arrow aligned to character vertical center\n                    val arrowStartX \u003d if (facingLeft) characterX else characterX + runFrameWidth * scale - (arrowBitmap.width * arrowScale) * 0.25f\n                    val playerCenterY \u003d characterY + (runFrameHeight * scale) / 2f\n                    val arrowHeight \u003d arrowBitmap.height * arrowScale\n                    val arrowStartY \u003d playerCenterY - arrowHeight / 2f\n                    arrows.add(\n                        Arrow(\n                            x \u003d arrowStartX,\n                            y \u003d arrowStartY,\n                            speedPxPerFrame \u003d arrowSpeedPxPerFrameDefault,\n                            movingLeft \u003d facingLeft\n                        )\n                    )\n                    hasFiredArrowThisAttack \u003d true\n                    playAttackSound()\n                }\n            }\n        } else {\n            currentFrame \u003d 0\n        }\n    }\n\n    private fun updateEnemies() {\n        val now \u003d System.currentTimeMillis()\n\n        // Quản lý số lượng quái: đảm bảo tối thiểu và thay thế ngay khi bị tiêu diệt, tối đa 3\n        val aliveBefore \u003d enemies.count { !it.isDestroyed }\n        if (aliveBefore \u003c minEnemiesAtStart) {\n            // Bổ sung các loại thiếu để đủ 3 loại khác nhau\n            val existingTypes \u003d enemies.filter { !it.isDestroyed }.map { it.type }.toMutableSet()\n            if (!existingTypes.contains(Enemy.Type.TORCH)) spawnEnemy(Enemy.Type.TORCH)\n            if (!existingTypes.contains(Enemy.Type.WARRIOR)) spawnEnemy(Enemy.Type.WARRIOR)\n            if (!existingTypes.contains(Enemy.Type.TNT)) spawnEnemy(Enemy.Type.TNT)\n        } else if (aliveBefore \u003c previousAliveEnemies \u0026\u0026 aliveBefore \u003c maxEnemies) {\n            // Trường hợp có kẻ địch bị diệt, sẽ respawn cùng loại đó trong checkEnemyHit\n        }\n\n        // Update positions and check collisions\n        playerBoxRect.set(\n            characterX,\n            characterY,\n            characterX + runFrameWidth * scale,\n            characterY + runFrameHeight * scale\n        )\n\n        for (enemy in enemies) {\n            if (enemy.isDestroyed) continue\n            // Di chuyển ngang một hướng cố định, wrap khi qua rìa\n            if (enemy.state !\u003d Enemy.State.ATTACK) {\n                val speed \u003d enemy.speedPxPerFrame\n                if (enemy.movingLeft) {\n                    enemy.x -\u003d speed\n                    enemy.facingLeft \u003d true\n                } else {\n                    enemy.x +\u003d speed\n                    enemy.facingLeft \u003d false\n                }\n\n                val cfgMove \u003d getConfig(enemy.type)\n                val fwMove \u003d (cfgMove.moveSheet.width / cfgMove.moveColumns)\n                val spriteWidth \u003d fwMove * cfgMove.scale\n                val quickOffset \u003d spriteWidth * 0.25f\n                // Nếu ra khỏi rìa trái, xuất hiện bên phải (vào nhanh hơn một chút)\n                if (enemy.x + spriteWidth \u003c 0f) {\n                    enemy.x \u003d width.toFloat() - quickOffset\n                }\n                // Nếu ra khỏi rìa phải, xuất hiện bên trái (vào nhanh hơn một chút)\n                if (enemy.x \u003e width.toFloat()) {\n                    enemy.x \u003d -spriteWidth + quickOffset\n                }\n            }\n\n            // Khoảng cách theo cả X và Y\n            val cfgForRange \u003d getConfig(enemy.type)\n            val fwRange \u003d (cfgForRange.moveSheet.width / cfgForRange.moveColumns)\n            val fhRange \u003d cfgForRange.moveSheet.height\n            val enemyCenterX \u003d enemy.x + (fwRange * cfgForRange.scale) / 2f\n            val enemyCenterY \u003d enemy.y + (fhRange * cfgForRange.scale) / 2f\n            val playerCenterX \u003d characterX + (runFrameWidth * scale) / 2f\n            val playerCenterY \u003d characterY + (runFrameHeight * scale) / 2f\n            val distX \u003d kotlin.math.abs(playerCenterX - enemyCenterX)\n            val distY \u003d kotlin.math.abs(playerCenterY - enemyCenterY)\n            val attackRangeX \u003d fwRange * cfgForRange.scale * 0.6f\n            val attackRangeY \u003d fhRange * cfgForRange.scale * 0.6f\n\n            // Xác định state\n            val shouldAttack \u003d distX \u003c attackRangeX \u0026\u0026 distY \u003c attackRangeY\n            if (shouldAttack) {\n                enemy.state \u003d Enemy.State.ATTACK\n                enemy.facingLeft \u003d playerCenterX \u003c enemyCenterX\n            } else {\n                enemy.state \u003d Enemy.State.MOVE\n            }\n\n            // Cập nhật frame animation\n            val cfgForAnim \u003d getConfig(enemy.type)\n            val duration \u003d cfgForAnim.frameDurationMs\n            if (now - enemy.frameTimerMs \u003e duration) {\n                val looping \u003d enemy.state \u003d\u003d Enemy.State.ATTACK || enemy.state \u003d\u003d Enemy.State.MOVE\n                if (looping) {\n                    val columns \u003d when (enemy.state) {\n                        Enemy.State.ATTACK -\u003e cfgForAnim.attackColumns\n                        Enemy.State.MOVE -\u003e cfgForAnim.moveColumns\n                        else -\u003e cfgForAnim.idleColumns\n                    }\n                    enemy.currentFrame \u003d (enemy.currentFrame + 1) % columns\n                    if (enemy.currentFrame \u003d\u003d 0) {\n                        if (enemy.state \u003d\u003d Enemy.State.ATTACK) enemy.attackReady \u003d true\n                        enemy.dealtDamageThisAttack \u003d false\n                    }\n                } else {\n                    enemy.currentFrame \u003d 0\n                }\n                enemy.frameTimerMs \u003d now\n            }\n\n            // Enemy attacks on contact\n            getEnemyHitboxInto(enemy, enemyHitboxRect)\n            if (RectF.intersects(playerBoxRect, enemyHitboxRect)) {\n                val canDamage \u003d if (enemy.state \u003d\u003d Enemy.State.ATTACK) (enemy.attackReady \u0026\u0026 !enemy.dealtDamageThisAttack) else now - lastHitTime \u003e hitCooldownMs\n                if (canDamage) {\n                    playerHealth \u003d (playerHealth - 1).coerceAtLeast(0)\n                    lastHitTime \u003d now\n                    Log.d(TAG, \&quot;Player bị tấn công! Máu còn: $playerHealth\&quot;)\n                    if (enemy.state \u003d\u003d Enemy.State.ATTACK) {\n                        enemy.dealtDamageThisAttack \u003d true\n                        enemy.attackReady \u003d false\n                    }\n                }\n            }\n        }\n\n        // Remove destroyed enemies, giữ lại để wrap-around khi ra khỏi màn hình\n        enemies.removeAll { it.isDestroyed }\n\n        // Nếu ít hơn tối đa, có thể spawn thêm để đạt tối đa 3 khi muốn\n        val aliveAfter \u003d enemies.count { !it.isDestroyed }\n        if (aliveAfter \u003c maxEnemies \u0026\u0026 aliveAfter \u003c minEnemiesAtStart) {\n            // Bổ sung những loại còn thiếu\n            val existingTypes \u003d enemies.filter { !it.isDestroyed }.map { it.type }.toMutableSet()\n            if (!existingTypes.contains(Enemy.Type.TORCH)) spawnEnemy(Enemy.Type.TORCH)\n            if (!existingTypes.contains(Enemy.Type.WARRIOR)) spawnEnemy(Enemy.Type.WARRIOR)\n            if (!existingTypes.contains(Enemy.Type.TNT)) spawnEnemy(Enemy.Type.TNT)\n        }\n        previousAliveEnemies \u003d enemies.count { !it.isDestroyed }\n    }\n\n    private fun updateArrows() {\n        if (arrowBitmap.width \u003c\u003d 0 || arrowBitmap.height \u003c\u003d 0) return\n        val iterator \u003d arrows.iterator()\n        while (iterator.hasNext()) {\n            val arrow \u003d iterator.next()\n            val dx \u003d if (arrow.movingLeft) -arrow.speedPxPerFrame else arrow.speedPxPerFrame\n            arrow.x +\u003d dx\n\n            // Remove when off-screen\n            if (arrow.x + arrowBitmap.width * arrowScale \u003c 0f || arrow.x \u003e width) {\n                iterator.remove()\n                continue\n            }\n\n            // Check collision with enemies\n            val arrowRect \u003d RectF(\n                arrow.x,\n                arrow.y,\n                arrow.x + arrowBitmap.width * arrowScale,\n                arrow.y + arrowBitmap.height * arrowScale\n            )\n            for (enemy in enemies) {\n                if (enemy.isDestroyed) continue\n                getEnemyHitboxInto(enemy, enemyHitboxRect)\n                if (RectF.intersects(arrowRect, enemyHitboxRect)) {\n                    enemy.health \u003d (enemy.health - 1).coerceAtLeast(0)\n                    if (enemy.health \u003d\u003d 0) enemy.isDestroyed \u003d true\n                    iterator.remove()\n                    break\n                }\n            }\n        }\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d CONTROL \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    fun startMoving(direction: Direction) {\n        movingDirection \u003d direction\n    }\n\n    fun stopMoving() {\n        movingDirection \u003d null\n    }\n\n    fun attack() {\n        Log.d(TAG, \&quot;attack: 1111\&quot;)\n        isAttacking \u003d true\n        currentFrame \u003d 0\n        hasFiredArrowThisAttack \u003d false\n        val characterBox \u003d RectF(\n            characterX,\n            characterY,\n            characterX + runFrameWidth * scale,\n            characterY + runFrameHeight * scale\n        )\n//        checkItemCollision(characterBox)\n        // Không gây sát thương ngay; damage sẽ áp dụng khi animation kết thúc (playerPendingAttack)\n\n        postDelayed({ isAttacking \u003d false }, 500)\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d COLLISION \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    private fun checkItemCollision(characterBox: RectF) {\n        for (item in items) {\n            if (!item.isDestroyed \u0026\u0026 RectF.intersects(characterBox, item.getBoundingBox())) {\n                item.isDestroyed \u003d true\n                Log.d(TAG, \&quot;Item ${item.id} bị phá hủy!\&quot;)\n            }\n        }\n    }\n\n    private fun checkEnemyHit(characterBox: RectF) {\n        val killed \u003d ArrayList\u003cEnemy\u003e()\n        for (enemy in enemies) {\n            getEnemyHitboxInto(enemy, enemyHitboxRect)\n            if (RectF.intersects(characterBox, enemyHitboxRect)) {\n                enemy.health \u003d (enemy.health - 1).coerceAtLeast(0)\n                if (enemy.health \u003d\u003d 0) {\n                    killed.add(enemy)\n                }\n            }\n        }\n        if (killed.isNotEmpty()) {\n            enemies.removeAll(killed)\n            // Spawn replacements immediately up to maxEnemies\n            val canSpawn \u003d (maxEnemies - enemies.size).coerceAtLeast(0)\n            val toSpawn \u003d minOf(canSpawn, killed.size)\n            repeat(toSpawn) { index -\u003e\n                val typeToRespawn \u003d killed.getOrNull(index)?.type ?: Enemy.Type.TORCH\n                spawnEnemy(typeToRespawn)\n            }\n        }\n    }\n\n    private fun getEnemyHitboxInto(enemy: Enemy, outRect: RectF) {\n        val cfg \u003d getConfig(enemy.type)\n        val fw \u003d (cfg.moveSheet.width / cfg.moveColumns)\n        val fh \u003d cfg.moveSheet.height\n        val widthScaled \u003d fw * cfg.scale\n        val heightScaled \u003d fh * cfg.scale\n        val insetX \u003d widthScaled * cfg.hitboxInsetXRatio\n        val insetY \u003d heightScaled * cfg.hitboxInsetYRatio\n        outRect.set(\n            enemy.x + insetX,\n            enemy.y + insetY,\n            enemy.x + widthScaled - insetX,\n            enemy.y + heightScaled - insetY\n        )\n    }\n\n    private fun spawnEnemy(type: Enemy.Type) {\n        val cfg \u003d getConfig(type)\n        val frameWidth \u003d cfg.moveSheet.width / cfg.moveColumns\n        val frameHeight \u003d cfg.moveSheet.height\n        val maxX \u003d (width - frameWidth * cfg.scale).coerceAtLeast(0f)\n        val maxY \u003d (height - frameHeight * cfg.scale).coerceAtLeast(0f)\n        val spawnX \u003d (0..maxX.toInt()).random().toFloat()\n        val spawnY \u003d (0..maxY.toInt()).random().toFloat()\n        val enemy \u003d Enemy(\n            id \u003d \&quot;enemy_${System.currentTimeMillis()}\&quot;,\n            x \u003d spawnX,\n            y \u003d spawnY,\n            bitmap \u003d cfg.idleSheet,\n            type \u003d type,\n            speedPxPerFrame \u003d 2.5f,\n            health \u003d 4\n        )\n        enemy.movingLeft \u003d listOf(true, false).random()\n        enemies.add(enemy)\n    }\n\n    private fun playAttackSound() {\n        if (!isEnabledSound) return\n        try {\n            attackPlayer?.seekTo(0)\n            attackPlayer?.play()\n        } catch (e: Exception) {\n            Log.e(TAG, \&quot;Error playing attack sound\&quot;, e)\n        }\n    }\n\n    private fun playWallHitSound() {\n        if (!isEnabledSound) return\n        try {\n            hitSoundPlayer?.seekTo(0)\n            hitSoundPlayer?.play()\n        } catch (e: Exception) {\n            Log.e(TAG, \&quot;Error playing wall hit sound\&quot;, e)\n        }\n    }\n\n    fun toggleSound(isEnabled: Boolean) {\n        isEnabledSound \u003d isEnabled\n    }\n}\n\n```\n\u003c/file_contents\u003e\n\n\u003c/attached_files\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\n@GameView.kt vì mỗi frame của các enemy đều là 192x192 nên tôi muốn các enemy đều xử lý anim y hệt như con torch\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[]}]}" />
      </map>
    </option>
  </component>
</project>